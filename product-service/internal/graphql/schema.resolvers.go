package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"

	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/models"
	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/service"
)

type Resolver struct {
	productService *service.ProductService
}

func NewResolver(productService *service.ProductService) *Resolver {
	return &Resolver{
		productService: productService,
	}
}

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *models.Category) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Name is the resolver for the name field.
func (r *productResolver) Name(ctx context.Context, obj *models.Product) (string, error) {
	return obj.Name, nil
}

// Slug is the resolver for the slug field.
func (r *productResolver) Slug(ctx context.Context, obj *models.Product) (string, error) {
	return obj.Slug, nil
}

// Description is the resolver for the description field.
func (r *productResolver) Description(ctx context.Context, obj *models.Product) (*string, error) {
	return &obj.Description, nil
}

// Price is the resolver for the price field.
func (r *productResolver) Price(ctx context.Context, obj *models.Product) (float64, error) {
	return obj.Price, nil
}

// Stock is the resolver for the stock field.
func (r *productResolver) Stock(ctx context.Context, obj *models.Product) (int, error) {
	return obj.Stock, nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *models.Product) (*models.Category, error) {
	return &obj.Category, nil
}

// Variants is the resolver for the variants field.
func (r *productResolver) Variants(ctx context.Context, obj *models.Product) ([]*models.ProductVariant, error) {
	variants := make([]*models.ProductVariant, len(obj.Variants))
	for i := range obj.Variants {
		variants[i] = &obj.Variants[i]
	}
	return variants, nil
}

// ID is the resolver for the id field.
func (r *productVariantResolver) ID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *variantAttributeResolver) ID(ctx context.Context, obj *models.VariantAttribute) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, slug string) (*models.Product, error) {
	return r.productService.GetProductBySlug(ctx, slug)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, limit *int, offset *int) ([]*models.Product, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	products, err := r.productService.ListProducts(ctx, l, o)
	if err != nil {
		return nil, err
	}

	result := make([]*models.Product, len(products))
	for i := range products {
		result[i] = &products[i]
	}
	return result, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, categoryID string, limit *int, offset *int) ([]*models.Product, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	products, err := r.productService.ListByCategory(ctx, categoryID, l, o)
	if err != nil {
		return nil, err
	}

	result := make([]*models.Product, len(products))
	for i := range products {
		result[i] = &products[i]
	}
	return result, nil
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string, limit *int, offset *int) ([]*models.Product, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}

	products, err := r.productService.SearchProducts(ctx, query, l, o)
	if err != nil {
		return nil, err
	}

	result := make([]*models.Product, len(products))
	for i := range products {
		result[i] = &products[i]
	}
	return result, nil
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// ProductVariant returns ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() ProductVariantResolver { return &productVariantResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// VariantAttribute returns VariantAttributeResolver implementation.
func (r *Resolver) VariantAttribute() VariantAttributeResolver { return &variantAttributeResolver{r} }

type categoryResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type variantAttributeResolver struct{ *Resolver }
