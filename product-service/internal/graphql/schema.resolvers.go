package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"strconv"

	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/graphql/model"
	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/models"
)

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *models.Category) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Products is the resolver for the products field.
func (r *categoryResolver) Products(ctx context.Context, obj *models.Category, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.ListByCategory(ctx, fmt.Sprintf("%d", obj.ID), l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// ID is the resolver for the id field.
func (r *collectionResolver) ID(ctx context.Context, obj *models.Collection) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Products is the resolver for the products field.
func (r *collectionResolver) Products(ctx context.Context, obj *models.Collection, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.ListByCollection(ctx, fmt.Sprintf("%d", obj.ID), l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// Gross is the resolver for the gross field.
func (r *priceResolver) Gross(ctx context.Context, obj *models.Price) (*model.Money, error) {
	return &model.Money{
		Amount:   obj.Amount,
		Currency: obj.Currency,
	}, nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *productAttributeResolver) ID(ctx context.Context, obj *models.ProductAttribute) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Values is the resolver for the values field.
func (r *productAttributeResolver) Values(ctx context.Context, obj *models.ProductAttribute) ([]string, error) {
	panic(fmt.Errorf("not implemented: Values - values"))
}

// ID is the resolver for the id field.
func (r *productVariantResolver) ID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, slug string, channel string) (*models.Product, error) {
	return r.productService.GetProductBySlug(ctx, slug)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, first int, after *string, channel string) (*models.ProductConnection, error) {
	offset := 0
	if after != nil {
		// Convert cursor to offset
		cursorID, err := strconv.ParseUint(*after, 10, 32)
		if err != nil {
			return nil, err
		}
		// Get the position of the cursor in the list
		position, err := r.productService.GetProductPosition(ctx, uint(cursorID))
		if err != nil {
			return nil, err
		}
		offset = position + 1
	}

	products, err := r.productService.ListProducts(ctx, first, offset)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	// Get total count for pagination
	totalCount, err := r.productService.GetTotalProducts(ctx)
	if err != nil {
		return nil, err
	}

	hasNextPage := offset+len(products) < totalCount

	return &models.ProductConnection{
		Edges:      edges,
		TotalCount: totalCount,
		PageInfo: &models.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
			StartCursor:     fmt.Sprintf("%d", products[0].ID),
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, slug string, channel string) (*models.Category, error) {
	return r.productService.GetCategoryBySlug(ctx, slug)
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, slug string, channel string) (*models.Collection, error) {
	return r.productService.GetCollectionBySlug(ctx, slug)
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, search string, sortBy model.ProductOrderField, sortDirection model.OrderDirection, first int, after *string, channel string) (*models.ProductConnection, error) {
	offset := 0
	if after != nil {
		// Convert cursor to offset
		cursorID, err := strconv.ParseUint(*after, 10, 32)
		if err != nil {
			return nil, err
		}
		// Get the position of the cursor in the list
		position, err := r.productService.GetProductPosition(ctx, uint(cursorID))
		if err != nil {
			return nil, err
		}
		offset = position + 1
	}

	products, err := r.productService.SearchProducts(ctx, search, first, offset, string(sortBy), string(sortDirection))
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	// Get total count for pagination
	totalCount, err := r.productService.GetTotalSearchResults(ctx, search)
	if err != nil {
		return nil, err
	}

	hasNextPage := offset+len(products) < totalCount

	pageInfo := &models.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: offset > 0,
	}

	if len(products) > 0 {
		pageInfo.StartCursor = fmt.Sprintf("%d", products[0].ID)
		pageInfo.EndCursor = fmt.Sprintf("%d", products[len(products)-1].ID)
	}

	return &models.ProductConnection{
		Edges:      edges,
		TotalCount: totalCount,
		PageInfo:   pageInfo,
	}, nil
}

// ID is the resolver for the id field.
func (r *reviewResolver) ID(ctx context.Context, obj *models.Review) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *reviewResolver) CreatedAt(ctx context.Context, obj *models.Review) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *variantAttributeResolver) ID(ctx context.Context, obj *models.VariantAttribute) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Collection returns CollectionResolver implementation.
func (r *Resolver) Collection() CollectionResolver { return &collectionResolver{r} }

// Price returns PriceResolver implementation.
func (r *Resolver) Price() PriceResolver { return &priceResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// ProductAttribute returns ProductAttributeResolver implementation.
func (r *Resolver) ProductAttribute() ProductAttributeResolver { return &productAttributeResolver{r} }

// ProductVariant returns ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() ProductVariantResolver { return &productVariantResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Review returns ReviewResolver implementation.
func (r *Resolver) Review() ReviewResolver { return &reviewResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// VariantAttribute returns VariantAttributeResolver implementation.
func (r *Resolver) VariantAttribute() VariantAttributeResolver { return &variantAttributeResolver{r} }

type categoryResolver struct{ *Resolver }
type collectionResolver struct{ *Resolver }
type priceResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productAttributeResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reviewResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type variantAttributeResolver struct{ *Resolver }
