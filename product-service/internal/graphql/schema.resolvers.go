package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"strings"

	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/graphql/model"
	"github.com/Geawn/Ms_E-commerce_BE/product-service/internal/models"
)

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *models.Category) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *collectionResolver) ID(ctx context.Context, obj *models.Collection) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Gross is the resolver for the gross field.
func (r *priceResolver) Gross(ctx context.Context, obj *models.Price) (*model.Money, error) {
	return &model.Money{
		Amount:   obj.Amount,
		Currency: obj.Currency,
	}, nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *productAttributeResolver) ID(ctx context.Context, obj *models.ProductAttribute) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *productVariantResolver) ID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, slug string, channel string) (*models.Product, error) {
	return r.productService.GetProductBySlug(ctx, slug)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.ListProducts(ctx, l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, categoryID string, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.ListByCategory(ctx, categoryID, l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// ProductsByCollection is the resolver for the productsByCollection field.
func (r *queryResolver) ProductsByCollection(ctx context.Context, collectionID string, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.ListByCollection(ctx, collectionID, l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string, first *int, channel string) (*models.ProductConnection, error) {
	l := 20
	if first != nil {
		l = *first
	}

	products, err := r.productService.SearchProducts(ctx, query, l, 0)
	if err != nil {
		return nil, err
	}

	edges := make([]*models.ProductEdge, len(products))
	for i, product := range products {
		edges[i] = &models.ProductEdge{
			Node:   product,
			Cursor: fmt.Sprintf("%d", product.ID),
		}
	}

	return &models.ProductConnection{
		Edges: edges,
		PageInfo: &models.PageInfo{
			HasNextPage:     len(products) == l,
			HasPreviousPage: false,
			StartCursor:     "",
			EndCursor:       fmt.Sprintf("%d", products[len(products)-1].ID),
		},
	}, nil
}

// ID is the resolver for the id field.
func (r *reviewResolver) ID(ctx context.Context, obj *models.Review) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *reviewResolver) CreatedAt(ctx context.Context, obj *models.Review) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *variantAttributeResolver) ID(ctx context.Context, obj *models.VariantAttribute) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Thumbnail is the resolver for the thumbnail field.
func (r *productResolver) Thumbnail(ctx context.Context, obj *models.Product, size *int, format *string) (*models.Image, error) {
	if obj.Thumbnail == nil {
		return nil, nil
	}

	// If size or format is provided, create a new image with the specified parameters
	if size != nil || format != nil {
		img := &models.Image{
			URL: obj.Thumbnail.URL,
			Alt: obj.Thumbnail.Alt,
		}

		if size != nil {
			img.Size = *size
			// Update URL to include size parameter
			img.URL = fmt.Sprintf("%s?size=%d", img.URL, *size)
		} else {
			img.Size = obj.Thumbnail.Size
		}

		if format != nil {
			img.Format = *format
			// Update URL to include format parameter
			if strings.Contains(img.URL, "?") {
				img.URL = fmt.Sprintf("%s&format=%s", img.URL, *format)
			} else {
				img.URL = fmt.Sprintf("%s?format=%s", img.URL, *format)
			}
		} else {
			img.Format = obj.Thumbnail.Format
		}

		return img, nil
	}

	return obj.Thumbnail, nil
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Collection returns CollectionResolver implementation.
func (r *Resolver) Collection() CollectionResolver { return &collectionResolver{r} }

// Price returns PriceResolver implementation.
func (r *Resolver) Price() PriceResolver { return &priceResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// ProductAttribute returns ProductAttributeResolver implementation.
func (r *Resolver) ProductAttribute() ProductAttributeResolver { return &productAttributeResolver{r} }

// ProductVariant returns ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() ProductVariantResolver { return &productVariantResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Review returns ReviewResolver implementation.
func (r *Resolver) Review() ReviewResolver { return &reviewResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// VariantAttribute returns VariantAttributeResolver implementation.
func (r *Resolver) VariantAttribute() VariantAttributeResolver { return &variantAttributeResolver{r} }

type categoryResolver struct{ *Resolver }
type collectionResolver struct{ *Resolver }
type priceResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productAttributeResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reviewResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type variantAttributeResolver struct{ *Resolver }
